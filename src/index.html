<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Parser</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        textarea {
            width: 100%;
            height: 150px;
        }
        button {
            margin-top: 10px;
        }
        .output {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>

<h1>CSV Parser</h1>
<textarea id="inputCSV"></textarea>
<br>
<button id="parseButton">sumbit</button>

<h2>result</h2>
<div id="output" class="output"></div>

<script>
  class CSVParser {
    constructor(csvString) {
      this.csvString = csvString;
    }

    isValidCSV(lines) {
      if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === ""))
        return false;

      const headers = this.splitCSVLine(lines[0]);

      if (headers.length === 0) return false;

      const expectedColumnCount = headers.length;

      for (let i = 1; i < lines.length; i++) {
        const columns = this.splitCSVLine(lines[i]);

        if (columns.length !== expectedColumnCount) return false;
      }

      return true;
    }

    splitCSVLine(line) {
      const regex = /(?:^|,)\s*(?:"([^"]*)"|'([^']*)'|([^",]*))/g;
      const matches = [];
      let match;

      while ((match = regex.exec(line)) !== null) {
        matches.push(match[1] || match[2] || match[3]);
      }

      return matches.map(m => m ? m.trim() : '').filter(Boolean);
    }

    sanitizeHeader(header) {
      return header.trim().replace(/^"|"$/g, "");
    }

    sanitizeValue(value) {
      if (value.startsWith('"') && value.endsWith('"')) {
        return value.slice(1, -1);
      }

      const numberValue = Number(value.replace(/,/g, ""));
      return isNaN(numberValue) ? value : numberValue;
    }

    parse() {
      const lines = this.csvString
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line.length > 0);

      if (lines.length === 0 || (lines.length === 1 && lines[0].length === 0)) {
        return [];
      }

      if (!this.isValidCSV(lines)) throw new Error('Invalid CSV format');

      this.headers = this.splitCSVLine(lines[0]).map((header) =>
        this.sanitizeHeader(header),
      );

      return lines.slice(1).map((line) => {
        const values = this.splitCSVLine(line);

        if (values.length !== this.headers.length)
          throw new Error('Invalid CSV format');

        return this.headers.reduce((obj, header, index) => {
          obj[header] = this.sanitizeValue(values[index]);

          return obj;
        }, {});
      });
    }
  }

  document.getElementById('parseButton').addEventListener('click', function() {
    const inputCSV = document.getElementById('inputCSV').value;

    try {
      const parser = new CSVParser(inputCSV);
      const result = parser.parse();

      document.getElementById('output').innerText = JSON.stringify(result, null, 1);
    } catch (error) {
      document.getElementById('output').innerText = error.message;
    }
  });
</script>

</body>
</html>
